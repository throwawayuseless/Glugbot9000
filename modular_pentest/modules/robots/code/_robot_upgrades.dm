/*
		Replaces "code\modules\mob\living\silicon\robot\robot_upgrades.dm"

		Purpose of modularization:
			The purpose of the modularized code is primarily to prevent updates being pushed by shiptest from causing
			conflict errors in the future. Shiptest loves to use single letter variables and non descriptive defines
			which make reading the code more difficult, and lead to various problems.

			Along with this, the code contained here is being refactored to be much more in line with TG Station,
			which will allow us to pull from TG Station, or various forks, for new updates and features without having to
			recode everything from scratch.

			Unfortunately, due to how many parts of the code are outdated, this is not a 1:1 copy of TG code. Eventually
			it would be best to update the system to be more in line, yet that would cause a much larger refactor of code
			across much more than the robot files.

			- Ossa


		Code Contained Here:
			The code contained within this file is for cyborg upgrade modules and their functionality
			This particular file is for general purpose modules, and the various procs being used.


		Individual loadouts, toolsets and Modules are located in their respective model files:

		Clown Cynorg Upgrades: clown_borg.dm
		Default Cyborg Upgrades: default_borg.dm
		Engineering Cyborg Upgrades: engi_borg.dm
		Janitor Cyborg Upgrades: jani_borg.dm
		Medical Cyborg Upgrades: med_borg.dm
		Miner Cyborg Upgrades: miner_borg.dm
		Ninja Cyborg Upgrades: ninja_borg.dm
		Peacekeeper Cyborg Upgrades: peace_borg.dm
		Science Cyborg Upgrades: science_borg.dm
		Security Cyborg Upgrades: sec_borg.dm
		Service Cyborg Upgrades: serv_borg.dm
		Syndicate Cyborg Upgeades: synd_borg.dm
*/

/* EXAMPLE FORMAT

//
// SERVICE APPARATUS - CODE (The code for the actual item)
//


//
// ROLLING TABLE - BOARD AND UPGRADE CODE (The code that is the upgrade install module)
//

/obj/item/borg/upgrade/???
	name = "???"
	desc = "???"
	icon_state = "module_???"
	require_model = TRUE //TRUE to limit to select modules, FALSE if all borgs get.
	model_type = list(/obj/item/robot_module/???) //Only if require_model = TRUE, list all borg types

	items_to_add = list(???) //required
	items_to_remove = list(???) //only required if something is being swapped.

//
// ROLLING TABLE BOARD DESIGN - mechfabricator_designs.dm (Required if you want the item to be printable)
//

/datum/design/borg_upgrade_???
	name = "???"
	id = "borg_upgrade_???"
	build_type = MECHFAB
	build_path = /obj/item/borg/upgrade/???
	materials = list(
		/datum/material/iron = 10000,
		/datum/material/titanium = 4000,
	)
	construction_time = 60
	category = list("Cyborg Upgrade Modules")
*/


/obj/item/borg/upgrade
	name = "borg upgrade module."
	desc = "Protected by FRM."
	icon = 'modular_pentest/modules/robots/icons/obj/borg_modules.dmi'
	icon_state = "module_general"
	w_class = WEIGHT_CLASS_SMALL
	var/locked = FALSE
	var/installed = 0
	var/require_model = FALSE
	var/list/model_type = null

	/// List of items to add with the module, if any
	var/list/items_to_add
	/// List of items to remove with the module, if any
	var/list/items_to_remove
	// if true, is not stored in the robot to be ejected if model is reset
	var/one_use = FALSE
	// If the module allows duplicates of itself to exist within the borg.
	// one_use technically makes this value not mean anything, maybe could be just one variable with flags?
	var/allow_duplicates = FALSE

/obj/item/borg/upgrade/proc/action(mob/living/silicon/robot/borg, mob/living/user = usr)
	if(borg.stat == DEAD)
		to_chat(user, span_warning("[src] will not function on a deceased cyborg!"))
		return FALSE
	if(model_type && !is_type_in_list(borg.module, model_type))
		to_chat(borg, span_alert("Upgrade mounting error! No suitable hardpoint detected."))
		to_chat(user, span_warning("There's no mounting point for the module!"))
		return FALSE
	if(!allow_duplicates && (locate(type) in borg.upgrades))
		to_chat(borg, span_alert("Upgrade mounting error! Hardpoint already occupied!"))
		to_chat(user, span_warning("The mounting point for the module is already occupied!"))
		return FALSE
	// Handles adding/removing items.
	if(length(items_to_add))
		install_items(borg, user, items_to_add)
	if(length(items_to_remove))
		remove_items(borg, user, items_to_remove)
	return TRUE

/obj/item/borg/upgrade/proc/deactivate(mob/living/silicon/robot/borg, mob/living/user = usr)
	if (!(src in borg.upgrades))
		return FALSE

	// Handles reverting the items back
	if(length(items_to_add))
		remove_items(borg, user, items_to_add)
	if(length(items_to_remove))
		install_items(borg, user, items_to_remove)
	return TRUE

// Handles adding items with the module
/obj/item/borg/upgrade/proc/install_items(mob/living/silicon/robot/borg, mob/living/user = usr, list/items)
	for(var/item_to_add in items)
		var/obj/item/module_item = new item_to_add(borg.module)
		borg.module.basic_modules += module_item
		borg.module.add_module(module_item, FALSE, TRUE)
	return TRUE

// Handles removing some items as the module is installed
/obj/item/borg/upgrade/proc/remove_items(mob/living/silicon/robot/borg, mob/living/user = usr, list/items)
	for(var/item_to_remove in items)
		var/obj/item/module_item = locate(item_to_remove) in borg.module.modules
		if (module_item)
			borg.module.remove_module(module_item, TRUE)
	return TRUE

//
// RENAME - BOARD AND UPGRADE CODE
//

/obj/item/borg/upgrade/rename
	name = "cyborg reclassification board"
	desc = "Used to rename a cyborg."
	icon_state = "module_general"
	var/heldname = ""
	one_use = TRUE

/obj/item/borg/upgrade/rename/attack_self(mob/user)
	var/new_heldname = sanitize_name(stripped_input(user, "Enter new robot name", "Cyborg Reclassification", heldname, MAX_NAME_LEN))
	if(!new_heldname || !user.is_holding(src))
		return
	heldname = new_heldname
	user.log_message("set \"[heldname]\" as a name in a cyborg reclassification board at [loc_name(user)]", LOG_GAME)

/obj/item/borg/upgrade/rename/action(mob/living/silicon/robot/borg, mob/living/user = usr)
	. = ..()
	if(!.)
		return .
	var/oldname = borg.real_name
	var/oldkeyname = key_name(borg)
	borg.custom_name = heldname
	borg.updatename()
	if(oldname == borg.real_name)
		borg.notify_ai(RENAME, oldname, borg.real_name)
	user.log_message("used a cyborg reclassification board to rename [oldkeyname] to [key_name(borg)]", LOG_GAME)

//
// RESTART - BOARD AND UPGRADE CODE
//

// This isn't an upgrade or part of the same path, but I'm gonna just stick it here because it's a tool used on cyborgs.
// A reusable tool that can bring borgs back to life. They gotta be repaired first, though.

/obj/item/borg/upgrade/restart
	name = "cyborg emergency reboot module"
	desc = "A reusable firmware reset tool that can force a reboot of a disabled-but-repaired cyborg, bringing it back online."
	w_class = WEIGHT_CLASS_SMALL
	icon_state = "module_general"
	one_use = TRUE

/obj/item/borg/upgrade/restart/pre_attack(mob/living/silicon/robot/borg, mob/living/user, params)
	if(!istype(borg))
		return ..()
	if(!borg.opened)
		to_chat(user, span_warning("You must access the cyborg's internals!"))
		return ..()
	if(borg.health < 0)
		to_chat(user, span_warning("You have to repair the cyborg before using this module!"))
		return ..()
	if(!(borg.stat & DEAD))
		to_chat(user, span_warning("This cyborg is already operational!"))
		return ..()

	if(borg.mind)
		borg.mind.grab_ghost()
		playsound(loc, 'sound/voice/liveagain.ogg', 75, TRUE)
	else
		playsound(loc, 'sound/machines/ping.ogg', 75, TRUE)

	borg.revive()
	borg.logevent("WARN -- System recovered from unexpected shutdown.")
	borg.logevent("System brought online.")
	return ..()

//
// ION THRUSTERS - BOARD AND UPGRADE CODE
//

/obj/item/borg/upgrade/thrusters
	name = "ion thruster upgrade"
	desc = "An energy-operated thruster system for cyborgs."
	icon_state = "module_general"

/obj/item/borg/upgrade/thrusters/action(mob/living/silicon/robot/borg, mob/living/user = usr)
	. = ..()
	if(!.)
		return .
	if(borg.ionpulse)
		to_chat(user, span_warning("This unit already has ion thrusters installed!"))
		return FALSE

	borg.ionpulse = TRUE
	borg.toggle_ionpulse() //Enabled by default

/obj/item/borg/upgrade/thrusters/deactivate(mob/living/silicon/robot/borg, mob/living/user = usr)
	. = ..()
	if(!.)
		return .
	borg.ionpulse_on = 0
	borg.ionpulse = FALSE


//
// SELF REPAIR - BOARD AND UPGRADE CODE
//

/mob/living/silicon/robot
	var/repair_module = FALSE

/obj/item/borg/upgrade/selfrepair
	name = "self-repair module"
	desc = "This module will repair the cyborg over time."
	icon_state = "module_general"
	require_model = TRUE
	var/repair_amount = -1
	var/repair_tick = 1
	var/msg_cooldown = 0
	var/on = FALSE
	var/powercost = 10
	var/datum/action/toggle_action

/obj/item/borg/upgrade/selfrepair/action(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if(.)
		if(R.repair_module)
			to_chat(user, span_warning("This unit is already equipped with a self-repair module!"))
			return FALSE

		icon_state = "selfrepair_off"
		toggle_action = new /datum/action/item_action/toggle(src)
		toggle_action.Grant(R)
		R.repair_module = TRUE

/obj/item/borg/upgrade/selfrepair/deactivate(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if (.)
		R.repair_module = FALSE
		toggle_action.Remove(R)
		QDEL_NULL(toggle_action)
		deactivate_sr()

/obj/item/borg/upgrade/selfrepair/ui_action_click()
	if(on)
		to_chat(toggle_action.owner, span_notice("You deactivate the self-repair module."))
		deactivate_sr()
	else
		to_chat(toggle_action.owner, span_notice("You activate the self-repair module."))
		activate_sr()

/obj/item/borg/upgrade/selfrepair/update_icon_state()
	if(toggle_action)
		icon_state = "selfrepair_[on ? "on" : "off"]"
	else
		icon_state = "module_general"
	return ..()

/obj/item/borg/upgrade/selfrepair/proc/activate_sr()
	START_PROCESSING(SSobj, src)
	on = TRUE
	update_appearance()

/obj/item/borg/upgrade/selfrepair/proc/deactivate_sr()
	STOP_PROCESSING(SSobj, src)
	on = FALSE
	update_appearance()

/obj/item/borg/upgrade/selfrepair/process()
	if(!repair_tick)
		repair_tick = 1
		return

	var/mob/living/silicon/robot/cyborg = toggle_action.owner

	if(istype(cyborg) && (cyborg.stat != DEAD) && on)
		if(!cyborg.cell)
			to_chat(cyborg, span_alert("Self-repair module deactivated. Please insert power cell."))
			deactivate_sr()
			return

		if(cyborg.cell.charge < powercost * 2)
			to_chat(cyborg, span_alert("Self-repair module deactivated. Please recharge."))
			deactivate_sr()
			return

		if(cyborg.health < cyborg.maxHealth)
			if(cyborg.health < 0)
				repair_amount = -2.5
				powercost = 30
			else
				repair_amount = -1
				powercost = 10
			cyborg.adjustBruteLoss(repair_amount)
			cyborg.adjustFireLoss(repair_amount)
			cyborg.updatehealth()
			cyborg.cell.use(powercost)
		else
			cyborg.cell.use(5)
		repair_tick = 0

		if((world.time - 2000) > msg_cooldown)
			var/msgmode = "standby"
			if(cyborg.health < 0)
				msgmode = "critical"
			else if(cyborg.health < cyborg.maxHealth)
				msgmode = "normal"
			to_chat(cyborg, span_notice("Self-repair is active in <span class='boldnotice'>[msgmode]</span> mode."))
			msg_cooldown = world.time
	else
		deactivate_sr()

//
// EXPAND - BOARD AND UPGRADE CODE
//

/obj/item/borg/upgrade/expand
	name = "borg expander"
	desc = "A cyborg resizer, it makes a cyborg huge."
	icon_state = "module_general"

/obj/item/borg/upgrade/expand/action(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if(.)

		if(R.hasExpanded)
			to_chat(usr, span_warning("This unit already has an expand module installed!"))
			return FALSE

		R.notransform = TRUE
		var/prev_lockcharge = R.lockcharge
		R.SetLockdown(1)
		R.set_anchored(TRUE)
		var/datum/effect_system/smoke_spread/smoke = new
		smoke.set_up(1, R.loc)
		smoke.start()
		sleep(2)
		for(var/i in 1 to 4)
			playsound(R, pick('sound/items/drill_use.ogg', 'sound/items/jaws_cut.ogg', 'sound/items/jaws_pry.ogg', 'sound/items/welder.ogg', 'sound/items/ratchet.ogg'), 80, TRUE, -1)
			sleep(12)
		if(!prev_lockcharge)
			R.SetLockdown(0)
		R.set_anchored(FALSE)
		R.notransform = FALSE
		R.resize = 2
		R.hasExpanded = TRUE
		R.update_transform()

/obj/item/borg/upgrade/expand/deactivate(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if (.)
		if (R.hasExpanded)
			R.hasExpanded = FALSE
			R.resize = 0.5
			R.update_transform()

//
// BORIS - BOARD AND UPGRADE CODE
//

/obj/item/borg/upgrade/ai
	name = "B.O.R.I.S. module"
	desc = "Bluespace Optimized Remote Intelligence Synchronization. An uplink device which takes the place of an MMI in cyborg endoskeletons, creating a robotic shell controlled by an AI."
	icon = 'icons/obj/module.dmi'
	icon_state = "boris"

/obj/item/borg/upgrade/ai/action(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if(.)
		if(R.shell)
			to_chat(user, span_warning("This unit is already an AI shell!"))
			return FALSE
		if(R.key) //You cannot replace a player unless the key is completely removed.
			to_chat(user, span_warning("Intelligence patterns detected in this [R.braintype]. Aborting."))
			return FALSE

		R.make_shell(src)

/obj/item/borg/upgrade/ai/deactivate(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if (.)
		if(R.shell)
			R.undeploy()
			R.notify_ai(DISCONNECT)

//
// SHIP ACCESS CHIP - BOARD AND UPGRADE CODE
//

/obj/item/borg/upgrade/ship_access_chip
	name = "silicon ship access chip"
	desc = "A module that grants cyborgs and AI access to the ship this was printed from."
	icon = 'modular_pentest/modules/robots/icons/obj/borg_modules.dmi'
	icon_state = "module_shipaccess"
	var/datum/overmap/ship/controlled/ship
	allow_duplicates = TRUE

/obj/item/borg/upgrade/ship_access_chip/examine(mob/user)
	. = ..()
	. += "The chip has access for [ship.name] installed."

/obj/item/borg/upgrade/ship_access_chip/action(mob/living/silicon/robot/robot, user = usr)
	. = ..()
	if(.)
		var/obj/item/borg/upgrade/ship_access_chip/chip = locate() in robot.module
		if(chip)
			to_chat(user, span_warning("[robot] already has access to [ship.name]!"))
			return FALSE

		chip = new(robot.module)
		robot.module.basic_modules += chip
		robot.module.add_module(chip, FALSE, TRUE)
		robot.add_ship_access(ship)

/obj/item/borg/upgrade/ship_access_chip/deactivate(mob/living/silicon/robot/robot, user = usr)
	. = ..()
	if (.)
		var/obj/item/borg/upgrade/ship_access_chip/chip = locate() in robot.module
		if (chip)
			robot.module.remove_module(chip, TRUE)
		robot.remove_ship_access(ship)

/obj/item/borg/upgrade/ship_access_chip/afterattack(mob/living/silicon/ai/ai, mob/user, proximity)
	. = ..()
	if(!proximity)
		return
	if(!istype(ai))
		return
	if(ai.has_ship_access(ship))
		to_chat(user, span_warning("[ai] already has access to [ship.name]!"))
		return

	to_chat(ai, span_notice("[user] has upgraded you with access to [ship.name]."))
	ai.add_ship_access(ship)
	to_chat(user, span_notice("You upgrade [ai]. [src] is consumed in the process."))
	qdel(src)

//
// APPARATUS DROP CODE
//

/obj/item/borg/apparatus/AltClick(mob/user)
	stored.forceMove(get_turf(usr))
	return
